---
title: Theory of AI4PKM (2) - How to Use AI for PKM
created: 2025-11-11
tags:
  - ai4pkm
  - knowledge-management
  - theory
  - barriers
series: Theory of AI4PKM
part: 2
previous: "[[Theory of AI4PKM (1) - Why PKM]]"
next: "[[Theory of AI4PKM (3) - AI4PKM Framework]]"
dg-publish: true
---
# Theory of AI4PKM (2) - Using AI for PKM

[[Theory of AI4PKM (1) - Why PKM|이전 글]]에서 지식 관리의 중요성과 정보-지식의 분류 체계 살펴봤다. 이번에는 AI를 활용하는 다양한 단계에 대해 생각해보자. 

## AI 활용 단계의 구분

AI는 이미 놀라운 능력을 갖추고 있다:
- 책 몇 권 분량의 컨텍스트를 한번에 처리
- 인간이 수십 분 걸리는 작업을 수초 만에 50% 이상 성공
- 필요에 따라 몇 시간, 며칠도 자율적으로 작업 가능

> Computer가 "두뇌를 위한 자전거"였다면, AI는 "두뇌를 위한 자동차"다.

하지만 대부분의 사람들은 이 능력의 10%도 활용하지 못한다. AI 활용 수준은 다음 5가지 기준으로 구분할 수 있다:

| 기준 | 낮은 수준 | 높은 수준 |
|------|----------|----------|
| **컨텍스트 양** | 수동으로 제한된 정보 제공 | 자동으로 필요한 모든 정보 접근 |
| **결과물의 크기** | 단편적 답변 | 복합적 산출물 (문서, 분석, 계획) |
| **작업의 복잡성** | 단일 질문-응답 | 다단계 워크플로우 |
| **반복 작업의 자동화** | 매번 수동 실행 | 정기/트리거 기반 자동화 |
| **결과에 대한 컨트롤** | AI 출력 복붙 | AI가 직접 파일 생성/수정 |

아래 다이어그램은 각 AI 활용 단계가 5가지 기준에서 어떤 수준인지 한눈에 보여준다:
![[ai-usage-stages-gemini2.png]]

## AI 활용 단계 높이기

### AI 활용 1단계: ChatGPT

대부분의 사람들에게 가장 익숙한 AI 활용 방식은 ChatGPT일 것이다. 하지만 ChatGPT는 가장 제한이 많은 활용 방식이기도 하다. 왜 그럴까?

| 현재 방식 | 문제점 |
|----------|--------|
| 사람이 AI 도움 영역 판단 | 기회 놓침 |
| 제한된 Context + 수동 프롬프트 | 매번 반복 |
| 결과물 일부만 AI 생성 | 비효율 |
| 사람이 복붙하여 활용 | 수동 작업 |

먼저, 사람이 "이건 AI한테 시켜볼까?" 하고 판단하는 순간 이미 많은 기회를 놓친다. AI가 도울 수 있는 영역은 생각보다 훨씬 넓기 때문이다. 또한 매번 필요한 맥락을 직접 입력해야 하고, AI가 생성한 결과물을 일일이 복사해서 붙여넣어야 한다. 결국 AI의 놀라운 역량 중 극히 일부만 활용하게 된다. 이 한계를 극복하려면 먼저 AI에게 더 많은 컨텍스트를 제공해야 한다.

### AI 활용 2단계: 컨텍스트 부여하기

1단계의 핵심 문제는 AI가 맥락 없이 일반적인 답변밖에 하지 못한다는 것이다. AI 활용도를 높이는 첫 번째 열쇠는 **더 많은 컨텍스트를 부여하는 것**이다.

| 도구 | 특성 | 한계 |
|------|------|------|
| **ChatGPT Projects** | 프로젝트별 문맥 제공 | 업로드 용량 제한, 수동 관리 |
| **NotebookLM** | 다수 문서 기반 질의응답 | 소스 타입 제한, 생성물 통제 어려움 |

ChatGPT Projects는 프로젝트별로 관련 파일을 업로드해 맥락을 제공할 수 있고, NotebookLM은 여러 문서를 연결해 질의응답할 수 있다. 하지만 가장 진보적인 NotebookLM도 근본적 한계가 있다. PDF나 문서 등 특정 포맷만 지원하고, 이미 추가된 소스의 업데이트가 어렵다. AI가 만든 결과물을 원하는 형태로 저장하기도 어렵고, 질문-응답만 가능할 뿐 자동화나 워크플로우 연결은 불가능하다.

결국 컨텍스트 양만 늘어날 뿐, "수동 업로드"와 "복붙"의 근본적 한계는 그대로다. 이를 해결하려면 완전히 다른 접근이 필요하다.

### AI 활용 3단계: Human-AI 공유 워크스페이스

"AI가 작업에 따라 컨텍스트를 알아서 찾아서 결과물을 만들면 얼마나 좋을까?" 이를 가능하게 하는 것이 **인간과 AI의 공유 워크스페이스**다. 이 단계에서 컨텍스트, 결과물, 복잡성, 컨트롤 4가지 기준이 크게 도약한다. 현재 이를 구현하는 가장 효과적인 방법은 Claude Code, Gemini CLI 같은 **CLI 에이전트**다:

| 특징 | 설명 |
|------|------|
| **파일시스템 접근** | AI가 사용자의 파일을 직접 읽고 쓸 수 있음 |
| **자동 컨텍스트 검색** | 작업에 필요한 파일을 AI가 알아서 찾음 |
| **결과물 직접 반영** | 복붙 없이 AI가 바로 파일 생성/수정 |

이로써 1~2단계의 핵심 문제들이 해결된다. AI가 작업에 맞는 파일을 스스로 찾아 활용하고, 매번 복붙하는 수고 없이 직접 파일에 저장한다. 워크스페이스에 재사용 가능한 프롬프트를 모아두면 반복 작업도 간소화된다. 물론 AI와 작업 공간을 공유하면 리스크도 따른다. AI가 파일을 잘못 수정하거나 삭제할 수 있기 때문이다:

| 전략 | 설명 |
|------|------|
| **파일 분리** | 인간이 작성한 원본과 AI 생성물을 별도 폴더로 관리 |
| **버전 관리** | Git으로 모든 변경사항 추적, 언제든 복원 가능 |
| **접근 제한** | 중요 파일에 대한 AI 접근 권한 설정 |

공유 워크스페이스가 구축되면 자연스럽게 다음 질문이 떠오른다: 매번 수동으로 실행해야 할까?

### AI 활용 4단계: Automated Workflows

공유 워크스페이스의 다음 진화는 **자동화**다. 매번 수동으로 실행하지 않고 AI가 알아서 정해진 작업을 수행하는 것이다. 워크플로우는 크게 두 가지 유형이 있다:

| 유형 | 설명 | 예시 |
|------|------|------|
| **Scheduled Workflow** | 정해진 시간에 정기 실행 | 매일 아침 컨텐츠 정리 |
| **Triggered Workflow** | 이벤트 발생 시 자동 실행 | 새 파일 생성 시 분석 |

Scheduled Workflow는 매일, 매주처럼 정해진 주기에 실행된다. Triggered Workflow는 특정 이벤트(새 파일 생성, 특정 폴더 변경 등)가 발생하면 자동으로 실행된다. AI4PKM에서 활용하는 핵심 워크플로우들을 보자:

| 워크플로우 | 주기 | 역할 |
|-----------|------|------|
| **DIR** (Daily Ingestion & Roundup) | 매일 | 일일 컨텐츠 수집 및 정리 |
| **CKU** (Continuous Knowledge Upkeep) | 지속 | 지식 업데이트 및 연결 |
| **WRP** (Weekly Roundup & Planning) | 매주 | 주간 회고 및 계획 수립 |

DIR은 매일 새로 수집된 컨텐츠를 정리하고, CKU는 지속적으로 지식 간 연결을 업데이트하며, WRP는 매주 회고와 계획을 자동 생성한다. 이런 자동화가 가져오는 가치는 일관성과 시간 절약이다. 하지만 여전히 "정해진 작업"만 수행한다. 목표만 주면 AI가 알아서 계획하고 실행하면 어떨까?

### AI 활용 5단계: Goal-driven Agents

자동화의 궁극적 진화는 **목표 기반 에이전트**다. 사용자가 고수준 목표만 설정하면 AI가 자율적으로 작업을 계획하고 실행한다. 이것이 현재 AI4PKM 개발의 최종 목표이기도 하다.

| 요소 | 설명 |
|------|------|
| **목표 정의** | 사용자가 달성하고자 하는 최종 상태 명시 |
| **자율 실행** | AI가 필요한 리서치, 분석, 계획을 자동 수행 |
| **피드백 루프** | 중간 결과물 보고 → 사용자 피드백 → 목표 달성까지 반복 |

이를 위해서는 몇 가지 요소가 필요하다. 먼저 "Q4 마케팅 전략 수립" 같은 **명확한 고수준 목표**가 있어야 한다. 그리고 사용자의 지식 베이스와 선호도라는 **개인 컨텍스트**, AI가 활용할 수 있는 프롬프트와 워크플로우 같은 **스킬과 도구**, 마지막으로 피드백을 반영하여 점진적으로 개선하는 **자율성과 학습 능력**이 필요하다.

Goal-driven Agent의 궁극적 형태는 **자기 개선 시스템**이다. 모든 상호작용에서 학습하고, 프롬프트와 워크플로우를 자동으로 개선하며, 사용자 선호도에 지속적으로 적응한다. 이 단계에서 모든 기준이 최고 수준에 도달하며, AI가 단순 실행자에서 목표 달성 파트너로 진화한다.

---

## AI 활용의 안티패턴들

지금까지 AI의 활용 단계를 다양한 수준에서 알아보았다. 하지만 AI를 활용하는 과정에서 생산성을 오히려 **해칠 수 있는** 안티패턴들도 존재한다. 이를 인식하고 피하는 것이 중요하다.

![[human-ai-anti-patterns-gemini.png]]

### AI로 인한 인간의 역량 퇴화
문제
- AI에 일 시켜놓고 딴짓하기
- AI 결과물 제대로 안보고 공유하기

해결책
- 인간이 block되는 상황을 최소화
- 여러 작업을 동시에 진행할 수 있는 환경

### AI로 인한 결과물의 평준화
- AI는 그럴듯한 답변을 내놓음
	- 시험에서 예전에는 그럴듯한 답변으로 중간은 갔지만 이제 최하점
- 인간의 숙제: 어떻게 차별화할 것인가?
	- 결과물에 자신의 개성 담기
	- 자신의 취향에 맞춰 엄격한 평가

### 창의적 몰입(Flow)의 파괴
- AI와 작업하면 역할이 계속 바뀜: 
	- 프롬프트 엔지니어 → 편집자 → 품질 관리자 → AI 관리자
- 깊은 몰입 상태(Flow State) 달성이 어려워짐
- 해결책: AI 작업과 깊은 사고 작업을 분리하여 시간 블록 배정
---
# Appendix

%% 
### AI 활용 3단계: PKM + Agentic AI

CLI Agent (예: Claude Code)가 새로운 패러다임을 열었다:

| 특징 | 설명 |
|-----|------|
| **작업 공간 통합** | AI가 개발자의 workspace 내에서 직접 작업 |
| **장기 자율 작업** | Github Issues → 작업 수행 → Pull Requests |
| **도구 활용** | 다양한 도구와 연동하여 복잡한 작업 수행 |

**핵심 인사이트**: 코딩은 프로그래밍 언어로 된 지식 노동이다. 코딩 도구를 일반 업무에 적용할 수 있다. LLM은 자연어와 각종 파일 처리에 능숙하기 때문이다. 즉 PKM + Agentic AI의 조합은 비개발자를 위한 혁명이다.

| 수준 | 변화 | 효과 |
|-----|------|------|
| **단일 작업** | AI가 작업 영역에서 할 일 발견 → 전체 맥락 파악 → 결과 직접 반영 | 수동 개입 최소화 |
| **반복 작업** | 자주 쓰는 프롬프트/워크플로우 자동화 | 일관된 품질 |
| **병렬 작업** | 여러 작업 동시 실행 | 시간 절약 |

 %%